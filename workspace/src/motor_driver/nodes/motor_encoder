#!/usr/bin/env python

import rospy
from std_msgs.msg import Int16
import RPi.GPIO as GPIO

"""
The encoder node publishes a Int16 message "wheel", the tick count.

These hook into differential_drive's pid_velocity node. One of the parameters is ticks_meter, 
(ticks per meter, presumably) which should be calibrated.S
"""

class MotorEncoder:

    def __init__(self):

        self.tick_count = 0
        # yellow_pin = rospy.get_param('~yellow_pin')
        # white_pin = rospy.get_param('~white_pin')
        yellow_pin = 11
        white_pin = 15
        
        self.yellow_pin = yellow_pin
        self.white_pin = white_pin

        GPIO.setmode(GPIO.BOARD)
        GPIO.setup(self.yellow_pin, GPIO.IN)
        # GPIO.setup(self.white_pin, GPIO.IN)

        GPIO.add_event_detect(self.yellow_pin, GPIO.RISING, callback=self.yellow_rising)
        # GPIO.add_event_detect(self.yellow_pin, GPIO.FALLING, callback=self.yellow_falling)
        # GPIO.add_event_detect(self.white_pin, GPIO.RISING, callback=self.white_rising)
        # GPIO.add_event_detect(self.white_pin, GPIO.FALLING, callback=self.white_falling)

        pub = rospy.Publisher('wheel', Int16, queue_size=10)
        rospy.init_node('motor_encoder', anonymous=False)
        rate = rospy.Rate(10) # 10hz
        

        while not rospy.is_shutdown():
            pub.publish(self.tick_count)
            rate.sleep()

    def yellow_rising(self, channel):
        self.tick_count += 1
        rospy.loginfo('yellow rising')

    # def yellow_falling(self, channel):
    #     self.tick_count += 1
    #     rospy.loginfo('yellow falling')

    # def white_rising(self, channel):
    #     self.tick_count += 1
    #     rospy.loginfo('white_rising')

    # def white_falling(self, channel):
    #     self.tick_count += 1
    #     rospy.loginfo('white_falling')


if __name__ == '__main__':
    try:
        MotorEncoder()
    except rospy.ROSInterruptException:
        pass