#! /usr/bin/env python
import struct
import serial
import time

import roslib
roslib.load_manifest('motor_driver')
import rospy
from std_msgs.msg import Float32
from dual_mc33926_rpi import motors, MAX_SPEED

"""
The motor node to subscribes to differential_drive's "motor_cmd", which is a Float32 message.

These hook into differential_drive's pid_velocity node. One of the parameters is ticks_meter, 
(ticks per meter, presumably) which should be calibrated.

Manually send a message with "rostopic pub /motor_cmd std_msgs/Float32 <FLOAT_CMD>"
"""

class MotorDriver:

	def __init__(self):

		rospy.init_node('motor_driver', anonymous=False)
		motor_num = rospy.get_param('~motor_num')
		self.backwards = rospy.get_param('~backwards')
		rospy.Subscriber("motor_cmd", Float32, self.callback)

		if motor_num == 1:
			self.motor = motors.motor1
		else:
			self.motor = motors.motor2

		self.speed = 0
		self.motor.enable()
		self.motor.setSpeed(0)

		# spin() simply keeps python from exiting until this node is stopped
		rospy.on_shutdown(self.shutdown)
		rospy.spin()


	def shutdown(self):
		self.motor.setSpeed(0)


	def callback(self, motor_cmd):
	    
		if motor_cmd.data > 100:
			speed = MAX_SPEED
		elif motor_cmd.data < -100:
			speed = -MAX_SPEED
		else:
			speed = int(round(MAX_SPEED*motor_cmd.data/100))

		if self.backwards:
			speed *= -1
		
		rospy.loginfo('Setting motor to speed %i' % speed)
		self.motor.setSpeed(speed)
		
		if self.speed < speed:
			step = 1
		else:
			step = -1

		for s in range(self.speed, speed, step):
			self.motor.setSpeed(speed)
			time.sleep(0.005)

		self.speed = speed




if __name__ == '__main__':

	motor_driver = MotorDriver()